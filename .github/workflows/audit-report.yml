name: PR Audit Report

on:
  workflow_dispatch:
    inputs:
      start_date:
        description: "Date de début (YYYY-MM-DD)"
        required: true
      end_date:
        description: "Date de fin (YYYY-MM-DD)"
        required: true
      target_branch:
        description: "Branche cible (ex: main)"
        required: true
        default: "main"


# Permissions minimales : lecture du contenu et des PRs uniquement.
permissions:
  contents: read
  pull-requests: read

env:
  GITHUB_TOKEN: ${{ secrets.API_TOKEN }}
  OWNER: ${{ github.repository_owner }}
  REPO:  ${{ github.event.repository.name }}

jobs:
  generate-report:
    runs-on: ubuntu-latest
    env:
      START:  ${{ inputs.start_date }}
      END:    ${{ inputs.end_date }}
      BRANCH: ${{ inputs.target_branch }}

    steps:    
    
      # Installe jq (JSON), wkhtmltopdf (conversion HTML→PDF) et une police sûre.
      
      - name: Install tools (jq + wkhtmltopdf)
        run: |
          set -euo pipefail
          sudo apt-get update -yq
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -yq --no-install-recommends \
            jq wkhtmltopdf fonts-dejavu-core

      # Construit un .txt d’audit basé sur les PRs (ouvertes/mergées) sur la période.
      
      - name: Build PR audit report (.txt)
        id: build_txt
        shell: bash
        run: |
          set -euo pipefail
          REPORT_TXT="Audit-${REPO}-${START}_to_${END}.txt"
          : > "${REPORT_TXT}"   # crée/vides le fichier

          # ---------- GET GitHub API ----------
          
          api() {
            curl -fsSL \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$1"
          }
          
          # fetch_all_pages(base_url) :
          #   - Récupère toutes les pages d’une ressource GitHub (per_page=100).
          #   - Boucle jusqu’à ce qu’aucune donnée ne soit renvoyée.
          #   - Concatène toutes les pages en un tableau JSON unique.
          
          fetch_all_pages() {
            local base_url="$1"
            local sep='?'; [[ "$base_url" == *\?* ]] && sep='&'
            local page=1
            {
              while :; do
                local url="${base_url}${sep}per_page=100&page=${page}"
                local data; data="$(api "$url")"
                local len; len="$(jq 'length' <<<"$data")"
                [[ "$len" -eq 0 ]] && break
                echo "$data"
                page=$((page+1))
              done
            } | jq -s 'if length==0 then [] else add end'
          }

          # ---------- Fonctions pour récupérer les données des PR ----------
          # fetch_prs_by_state(state)     : renvoie toutes les PRs selon le state ("open" ou "closed").
          # fetch_single_pr(number)       : renvoie le détail complet d’une PR (merged_by, dates, etc.).
          # fetch_issue_comments(number)  : renvoie tous les commentaires associés à une PR (via son issue).
          # fetch_pr_reviews(number)      : renvoie toutes les reviews d’une PR (APPROVED, CHANGES_REQUESTED…).
          
          fetch_prs_by_state() {   fetch_all_pages "https://api.github.com/repos/${OWNER}/${REPO}/pulls?state=$1"; }
          fetch_single_pr()    {   api "https://api.github.com/repos/${OWNER}/${REPO}/pulls/$1"; }
          fetch_issue_comments(){  fetch_all_pages "https://api.github.com/repos/${OWNER}/${REPO}/issues/$1/comments"; }
          fetch_pr_reviews()   {   fetch_all_pages "https://api.github.com/repos/${OWNER}/${REPO}/pulls/$1/reviews"; }

          all_closed="$(fetch_prs_by_state closed)"   
          all_open="$(fetch_prs_by_state open)"       

          # Filtre les PRs mergées : base = branche cible, période = START → END
          
          merged_prs="$(
            jq --arg s "${START}" --arg e "${END}" --arg branch "${BRANCH}" '
              [ .[]
                | select(.merged_at != null)
                | select(.base.ref == $branch)
                | select(.merged_at[0:10] >= $s and .merged_at[0:10] <= $e)
              ]
            ' <<<"$all_closed"
          )"

          # Filtre les PRs ouvertes créées dans la période sur la branche cible
          open_prs="$(
            jq --arg s "${START}" --arg e "${END}" --arg branch "${BRANCH}" '
              [ .[]
                | select(.state == "open")
                | select(.base.ref == $branch)
                | select(.created_at[0:10] >= $s and .created_at[0:10] <= $e)
              ]
            ' <<<"$all_open"
          )"

          # Construit un index combinant PRs mergées et ouvertes, triées par date décroissante

          combined_index="$(
            jq -s '
              def pick(o): {number: o.number, created_at: o.created_at};
              (.[0] // []) as $merged
              | (.[1] // []) as $open
              | ( ($merged | map(pick(.))) + ($open | map(pick(.))) )
              | sort_by(.created_at) | reverse
            ' <(echo "$merged_prs") <(echo "$open_prs")
          )"

          total="$(jq 'length' <<<"$combined_index")"
          if [[ "$total" -eq 0 ]]; then
            echo "Aucun résultat trouvé entre le ${START} et ${END} sur ${BRANCH}." >> "${REPORT_TXT}"
            echo "TXT_READY=${REPORT_TXT}" >> $GITHUB_ENV
            exit 0
          fi

          # ---------- Génère le rapport pour chaque PR ----------
          
          # numéro, titre, auteur, date de création
          
          while IFS= read -r n; do
            jq -r --argjson num "$n" \
                  --arg fmt_in "%Y-%m-%dT%H:%M:%SZ" \
                  --arg fmt_out "%Y-%m-%d" \
                  -s '
              add
              | map(select(.number == $num)) | .[0]
              | "PR #\(.number) — \(.title)\n" +
                "Auteur : \(.user.login)\n" +
                "Créée : \(.created_at | strptime($fmt_in) | strftime($fmt_out))"
            ' <(echo "$all_open") <(echo "$all_closed") >> "${REPORT_TXT}"

           # Statut de la PR (open, merged, closed)
           
            in_open="$(jq --argjson num "$n" 'any(.[]; .number == $num)' <<<"$open_prs")"
            in_merged="$(jq --argjson num "$n" 'any(.[]; .number == $num)' <<<"$merged_prs")"
            if [[ "$in_open" == "true" ]]; then
              echo "Statut : open" >> "${REPORT_TXT}"
            elif [[ "$in_merged" == "true" ]]; then
              pr_detail="$(fetch_single_pr "$n")"
              merged_by="$(jq -r '.merged_by.login // "inconnu"' <<< "$pr_detail")"
              merged_date="$(jq -r --arg fmt_in "%Y-%m-%dT%H:%M:%SZ" --arg fmt_out "%Y-%m-%d" \
                              '.merged_at | strptime($fmt_in) | strftime($fmt_out)' <<< "$pr_detail")"
              echo "Mergé par : ${merged_by} le ${merged_date}" >> "${REPORT_TXT}"
              echo "Statut : closed" >> "${REPORT_TXT}"
            else
              echo "Statut : inconnu" >> "${REPORT_TXT}"
            fi

            # Liste des reviewers de la PR
            
            reviews_json="$(fetch_pr_reviews "$n")"
            approved_count="$(jq '[.[] | select(.state == "APPROVED")] | length' <<<"$reviews_json")"
            if [[ "$approved_count" -eq 0 ]]; then
              echo "Validations: Aucune approbation" >> "${REPORT_TXT}"
            else
              echo "Validations:" >> "${REPORT_TXT}"
              jq -r --arg fmt_in "%Y-%m-%dT%H:%M:%SZ" --arg fmt_out "%Y-%m-%d" '
                [ .[] | select(.state == "APPROVED") ]
                | sort_by(.submitted_at)
                | map("- \(.user.login) | \(.submitted_at | strptime($fmt_in) | strftime($fmt_out))")
                | .[]
              ' <<< "$reviews_json" >> "${REPORT_TXT}"
            fi

            # Liste des commentaires associés
            
            comments_json="$(fetch_issue_comments "$n")"
            ccount="$(jq 'length' <<<"$comments_json")"
            if [[ "$ccount" -eq 0 ]]; then
              echo "Commentaires: Aucun commentaire" >> "${REPORT_TXT}"
            else
              echo "Commentaires:" >> "${REPORT_TXT}"
              jq -r '
                .[] | "- \(.user.login) | \(.body | gsub("\r?\n"; " ") | gsub(" +"; " "))"
              ' <<< "$comments_json" >> "${REPORT_TXT}"
            fi

            echo "----------------------------------------------" >> "${REPORT_TXT}"
          done < <(jq -r '.[].number' <<<"$combined_index")

          echo "TXT_READY=${REPORT_TXT}" >> $GITHUB_ENV

     # ---------- Génération du PDF ----------
      - name: Convert TXT to PDF (wkhtmltopdf)
        shell: bash
        run: |
          set -euo pipefail
          HTML="report.html"
          PDF="${TXT_READY%.txt}.pdf"

          esc() { sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'; }

          {
            echo '<!doctype html><html><head><meta charset="utf-8">'
            echo '<style>'
            echo 'body{font-family:Arial,Helvetica,sans-serif;font-size:12px;color:#111;margin:24px;}'
            echo 'h1{font-size:18px;margin:0 0 6px 0;}'
            echo '.meta{font-size:11px;color:#555;margin:0 0 12px 0;}'
            echo 'pre{white-space:pre-wrap;font-family:Courier,monospace;font-size:11px;line-height:1.4;margin:0;}'
            echo '</style></head><body>'
            echo "  <h1>PR Audit — ${REPO}</h1>"
            echo "  <div class=\"meta\">Branche : <b>${BRANCH}</b> · Période : <b>${START}</b> → <b>${END}</b> · Généré le : <b>$(date '+%Y-%m-%d')</b></div>"
            echo "  <hr style=\"margin:16px 0; border:none; border-top:1px solid #ccc;\">"
            echo "  <pre>"
            esc < "${TXT_READY}"
            echo "  </pre>"
            echo '</body></html>'
          } > "${HTML}"

          wkhtmltopdf "${HTML}" "${PDF}"
          echo "PDF_READY=${PDF}" >> $GITHUB_ENV

      - name: Upload PDF artifact
        uses: actions/upload-artifact@v4
        with:
          name: audit-report-${{ env.REPO }}
          path: ${{ env.PDF_READY }}
