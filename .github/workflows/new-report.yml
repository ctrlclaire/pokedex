name: PR Audit Report (Hardened, no-checkout)

on:
  workflow_dispatch:
    inputs:
      start_date:
        description: "Date de début (YYYY-MM-DD)"
        required: true
      end_date:
        description: "Date de fin (YYYY-MM-DD)"
        required: true
      target_branch:
        description: "Branche cible (ex: main)"
        required: true
        default: "main"
      include_comments:
        description: "Inclure le texte des commentaires (true/false)"
        required: false
        default: "false"

permissions:
  contents: read
  pull-requests: read

jobs:
  generate-report:
    runs-on: ubuntu-latest
    env:
      OWNER:  ${{ github.repository_owner }}
      REPO:   ${{ github.event.repository.name }}
      START:  ${{ inputs.start_date }}
      END:    ${{ inputs.end_date }}
      BRANCH: ${{ inputs.target_branch }}
      INCLUDE_COMMENTS: ${{ inputs.include_comments }}

    steps:
      - name: Install tools (jq + wkhtmltopdf)
        run: |
          set -euo pipefail
          sudo apt-get update -yq
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -yq --no-install-recommends \
            jq wkhtmltopdf fonts-dejavu-core ca-certificates

      - name: Validate inputs (dates + branch exists)
        shell: bash
        run: |
          set -euo pipefail
          is_iso() { [[ "$1" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; }

          if ! is_iso "${START}"; then
            echo "Input start_date invalide: ${START} (YYYY-MM-DD attendu)"; exit 2
          fi
          if ! is_iso "${END}"; then
            echo "Input end_date invalide: ${END} (YYYY-MM-DD attendu)"; exit 2
          fi
          if [[ "${END}" < "${START}" ]]; then
            echo "end_date (${END}) < start_date (${START})"; exit 2
          fi

          # Vérifie la branche via l’API officielle
          REF_STATUS=$(curl -fsS -o /dev/null -w "%{http_code}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "User-Agent: pr-audit-script" \
            "https://api.github.com/repos/${OWNER}/${REPO}/git/ref/heads/${BRANCH}" || true)
          if [[ "${REF_STATUS}" != "200" ]]; then
            echo "Branche introuvable: ${BRANCH} (HTTP ${REF_STATUS})"; exit 2
          fi

          INCLUDE_COMMENTS=$(echo "${INCLUDE_COMMENTS:-false}" | tr '[:upper:]' '[:lower:]')
          echo "INCLUDE_COMMENTS=${INCLUDE_COMMENTS}" >> "$GITHUB_ENV"

      - name: Build PR audit report (.txt) with FG-PAT (scoped step)
        id: build_txt
        shell: bash
        env:
          # Fine-Grained PAT lecture seule, limité à ce repo
          GITHUB_FG_PAT: ${{ secrets.API_TOKEN }}
        run: |
          set -euo pipefail
          echo "::add-mask::${GITHUB_FG_PAT}"

          REPORT_TXT="Audit-${REPO}-${START}_to_${END}.txt"
          : > "${REPORT_TXT}"

          UA="pr-audit-script"
          api() {
            curl -fsSL --retry 5 --retry-all-errors --max-time 60 \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer ${GITHUB_FG_PAT}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -H "User-Agent: ${UA}" \
              "$1"
          }

          fetch_all_pages() {
            local base_url="$1"
            local sep='?'; [[ "$base_url" == *\?* ]] && sep='&'
            local page=1
            {
              while :; do
                local url="${base_url}${sep}per_page=100&page=${page}"
                local data; data="$(api "$url")"
                local len; len="$(jq 'length' <<<"$data")"
                [[ "$len" -eq 0 ]] && break
                echo "$data"
                page=$((page+1))
              done
            } | jq -s 'if length==0 then [] else add end'
          }

          fetch_prs_by_state() {   fetch_all_pages "https://api.github.com/repos/${OWNER}/${REPO}/pulls?state=$1"; }
          fetch_single_pr()    {   api "https://api.github.com/repos/${OWNER}/${REPO}/pulls/$1"; }
          fetch_issue_comments(){  fetch_all_pages "https://api.github.com/repos/${OWNER}/${REPO}/issues/$1/comments"; }
          fetch_pr_reviews()   {   fetch_all_pages "https://api.github.com/repos/${OWNER}/${REPO}/pulls/$1/reviews"; }

          all_closed="$(fetch_prs_by_state closed)"
          all_open="$(fetch_prs_by_state open)"

          merged_prs="$(
            jq --arg s "${START}" --arg e "${END}" --arg branch "${BRANCH}" '
              [ .[]
                | select(.merged_at != null)
                | select(.base.ref == $branch)
                | select(.merged_at[0:10] >= $s and .merged_at[0:10] <= $e)
              ]
            ' <<<"$all_closed"
          )"

          open_prs="$(
            jq --arg s "${START}" --arg e "${END}" --arg branch "${BRANCH}" '
              [ .[]
                | select(.state == "open")
                | select(.base.ref == $branch)
                | select(.created_at[0:10] >= $s and .created_at[0:10] <= $e)
              ]
            ' <<<"$all_open"
          )"

          combined_index="$(
            jq -s '
              def pick(o): {number: o.number, created_at: o.created_at};
              (.[0] // []) as $merged
              | (.[1] // []) as $open
              | ( ($merged | map(pick(.))) + ($open | map(pick(.))) )
              | sort_by(.created_at) | reverse
            ' <(echo "$merged_prs") <(echo "$open_prs")
          )"

          total="$(jq 'length' <<<"$combined_index")"
          if [[ "$total" -eq 0 ]]; then
            echo "Aucun résultat trouvé entre ${START} et ${END} sur ${BRANCH}." >> "${REPORT_TXT}"
            echo "TXT_READY=${REPORT_TXT}" >> $GITHUB_ENV
            exit 0
          fi

          while IFS= read -r n; do
            pr_json="$(jq -s --argjson num "$n" 'add | map(select(.number==$num)) | .[0]' \
                       <(echo "$all_open") <(echo "$all_closed"))"

            title="$(jq -r '.title' <<< "$pr_json")"
            author_login="$(jq -r '.user.login' <<< "$pr_json")"
            created_fmt="$(jq -r --arg fi "%Y-%m-%dT%H:%M:%SZ" --arg fo "%Y-%m-%d" \
                           '.created_at | strptime($fi) | strftime($fo)' <<< "$pr_json")"

            {
              echo "PR #${n} — ${title}"
              echo "Auteur : ${author_login}"
              echo "Créée : ${created_fmt}"
            } >> "${REPORT_TXT}"

            in_open="$(jq --argjson num "$n" 'any(.[]; .number == $num)' <<<"$open_prs")"
            in_merged="$(jq --argjson num "$n" 'any(.[]; .number == $num)' <<<"$merged_prs")"

            if [[ "$in_open" == "true" ]]; then
              echo "Statut : open" >> "${REPORT_TXT}"
            elif [[ "$in_merged" == "true" ]]; then
              pr_detail="$(fetch_single_pr "$n")"
              merged_by="$(jq -r '.merged_by.login // "inconnu"' <<< "$pr_detail")"
              merged_date="$(jq -r --arg fi "%Y-%m-%dT%H:%M:%SZ" --arg fo "%Y-%m-%d" \
                                '.merged_at | strptime($fi) | strftime($fo)' <<< "$pr_detail")"
              echo "Mergé par : ${merged_by} le ${merged_date}" >> "${REPORT_TXT}"
              echo "Statut : closed" >> "${REPORT_TXT}"
            else
              echo "Statut : closed (non-merged ou inconnu)" >> "${REPORT_TXT}"
            fi

            reviews_json="$(fetch_pr_reviews "$n")"
            approved_count="$(jq '[.[] | select(.state=="APPROVED")] | length' <<<"$reviews_json")"
            if [[ "$approved_count" -eq 0 ]]; then
              echo "Validations: Aucune approbation" >> "${REPORT_TXT}"
            else
              echo "Validations:" >> "${REPORT_TXT}"
              jq -r --arg fi "%Y-%m-%dT%H:%M:%SZ" --arg fo "%Y-%m-%d" '
                [ .[] | select(.state=="APPROVED") ]
                | sort_by(.submitted_at)
                | map("- \(.user.login) | \(.submitted_at | strptime($fi) | strftime($fo))")
                | .[]
              ' <<< "$reviews_json" >> "${REPORT_TXT}"
            fi

            if [[ "${INCLUDE_COMMENTS}" == "true" ]]; then
              comments_json="$(fetch_issue_comments "$n")"
              ccount="$(jq 'length' <<<"$comments_json")"
              if [[ "$ccount" -eq 0 ]]; then
                echo "Commentaires: Aucun commentaire" >> "${REPORT_TXT}"
              else
                echo "Commentaires:" >> "${REPORT_TXT}"
                jq -r '
                  .[] | "- \(.user.login) | \(.body | gsub("\r?\n"; " ") | gsub(" +"; " "))"
                ' <<< "$comments_json" >> "${REPORT_TXT}"
              fi
            fi

            echo "----------------------------------------------" >> "${REPORT_TXT}"
          done < <(jq -r '.[].number' <<<"$combined_index")

          echo "TXT_READY=${REPORT_TXT}" >> $GITHUB_ENV

      - name: Convert TXT to PDF (wkhtmltopdf hardened)
        shell: bash
        run: |
          set -euo pipefail
          HTML="report.html"
          PDF="${TXT_READY%.txt}.pdf"

          esc() { sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'; }

          {
            echo '<!doctype html><html><head><meta charset="utf-8">'
            echo '<meta http-equiv="Content-Security-Policy" content="default-src '\''none'\''; style-src '\''self'\'' '\''unsafe-inline'\''">'
            echo '<style>'
            echo 'body{font-family:Arial,Helvetica,sans-serif;font-size:12px;color:#111;margin:24px;}'
            echo 'h1{font-size:18px;margin:0 0 6px 0;}'
            echo '.meta{font-size:11px;color:#555;margin:0 0 12px 0;}'
            echo 'pre{white-space:pre-wrap;font-family:Courier,monospace;font-size:11px;line-height:1.4;margin:0;}'
            echo '</style></head><body>'
            echo "  <h1>PR Audit — ${REPO}</h1>"
            echo "  <div class=\"meta\">Branche : <b>${BRANCH}</b> · Période : <b>${START}</b> → <b>${END}</b> · Généré le : <b>$(date '+%Y-%m-%d')</b></div>"
            echo "  <hr style=\"margin:16px 0; border:none; border-top:1px solid #ccc;\">"
            echo "  <pre>"
            esc < "${TXT_READY}"
            echo "  </pre>"
            echo '</body></html>'
          } > "${HTML}"

          wkhtmltopdf \
            --disable-javascript \
            --enable-local-file-access=false \
            --disable-local-file-access \
            --load-error-handling ignore \
            --quiet \
            "${HTML}" "${PDF}"

          echo "PDF_READY=${PDF}" >> $GITHUB_ENV

      - name: Upload PDF artifact (24h retention)
        uses: actions/upload-artifact@v4
        with:
          name: audit-report-${{ env.REPO }}
          path: ${{ env.PDF_READY }}
          retention-days: 1
